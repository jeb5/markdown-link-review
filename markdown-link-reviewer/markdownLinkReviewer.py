import argparse
import asyncio
import requests
from progressBar import ProgressBar
from brokenUrls import linkTestLoop
import markdown
import os
from link import buildLinksWCache, linksToCache, linksToLog
from refinementInterface import refinementLoop
from utils import MarkdownException, LinkScrapingException, BuildWithCacheException


def parseArgs():
	parser = argparse.ArgumentParser()
	parser.add_argument("markdownFile", nargs="?", help="The path to a markdown file to be parsed")
	parser.add_argument("--url", "-u", dest="markdownUrl", type=str, help="The url of a markdown file to be parsed")
	parser.add_argument("--refine", "-r", dest="refine", action="store_true", help="Refine problem links with selenium")
	parser.add_argument("--noCache", "-nc", dest="noCache", action="store_true", help="Don't use cache files from the mlrDirectory")
	parser.add_argument("--mlrDirectory", "-m", dest="mlrDirectory", default="mlrFiles", type=str, help="The path to the directory in which the output csv file, updated markdown file, changelog and the cache file will be generated")
	return parser.parse_args()


def getMDFileText(args):
	if args.markdownFile:
		with open(args.markdownFile, "r") as rmFile:
			return rmFile.read()
	elif args.markdownUrl:
		res = requests.get(args.markdownUrl)
		if res.status_code != 200:
			raise MarkdownException("Request responded with status code " + str(res.status_code))
		return res.text
	else:
		raise MarkdownException("No markdown file specified")


def main():
	args = parseArgs()
	os.makedirs(args.mlrDirectory, exist_ok=True)

	links = None
	try:
		md = getMDFileText(args)
		rawLinks = markdown.getMDLinks(md)
		linkCache = os.path.join(args.mlrDirectory, "linkCache.csv")
		if not args.noCache and os.path.isfile(linkCache):
			with open(linkCache, "r") as csvFile:
				links = buildLinksWCache(rawLinks, csvFile)
		else:
			links = buildLinksWCache(rawLinks)

		bar = ProgressBar(len(links) - 1, "Finding broken links...")
		asyncio.run(linkTestLoop(links, bar))

		suspects = [link for link in links if link.needsJudgement()]
		if len(suspects) != 0:
			bar = ProgressBar(len(suspects) - 1, "Judging problem links...")
			asyncio.run(refinementLoop(suspects, bar))

	except MarkdownException as e:
		print("Getting markdown file failed: " + str(e))
	except LinkScrapingException as e:
		print("Error parsing links from markdown: " + str(e))
	except BuildWithCacheException as e:
		print("Error building links list: " + str(e))
	except KeyboardInterrupt:
		print("\nProgram canceled")
		return 0
	finally:
		if links != None and not args.noCache:
			try:
				linkCache = os.path.join(args.mlrDirectory, "linkCache.csv")
				with open(linkCache, "w+") as csvFile:
					linksToCache(links, csvFile)
				print("Saved to cache")
			except Exception as e:
				print("Error saving cache back into file: " + str(e))
	if links != None:
		updatedLinks = [link for link in links if link.problem != None]
		if len(updatedLinks) != 0:

			try:
				linkLog = os.path.join(args.mlrDirectory, "linkLog.txt")
				with open(linkLog, "w") as llFile:
					linksToLog(updatedLinks, llFile)
				print("Saved updated links into log file")
			except Exception as e:
				print("Error saving updated links to log file:" + str(e))


if __name__ == "__main__":
	main()
# TODO: make program into more general "Test markdown file for broken links" usecase
# In selenium refinement, offer editable problem field, which is prefilled with autogenerated problem, but
# can be edited to become a custom problem message for usage in a pull request change log.
# Also offer a "replacement" field, which may be autofilled with the permanent redirect url, or can be
# customised by the user.
# The replacement field can be used to output a repaired markdown file
# A repaired markdown file and change log will be the ultimate output
